       Hima Rani Mathews 
19BCE1532
Date:26/04/2021 
LAB 10 
SEMAPHORES   

Aim:  
  To write C programs for understanding the concept of semaphores using classical process synchronization problems. You need to fill up the commented lines in the given codes. Screenshots of the output needs to be pasted after successful execution of each problem.


TASK 1: PRODUCER-CONSUMER PROBLEM 

CODE 
#include<stdio.h>
#include<pthread.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<semaphore.h>
sem_t empty,full,mutex;
char buf[10];
void* producer(void* arg)
{
int i;
printf("inside producer\n");
for(i=0;i<10;i++)
{
sem_wait(&empty);
sem_wait(&mutex);
buf[i]=i;
printf("item produced is %d\n",buf[i]);
sem_post(&mutex);
sem_post(&full);
sleep(1);
}
pthread_exit("producer\n");
}
void* consumer(void*arg)
{
int j;
printf("inside consumer\n");
for(j=0;j<10;j++)
{
sem_wait(&full);
sem_wait(&mutex);
j=buf[j];
printf("consumed item is %d\n",buf[j]);
sem_post(&mutex);
sem_post(&empty);
sleep(2);
}
pthread_exit("consumer\n");
}
int main()
{
pthread_t pid1,pid2;
sem_init(&empty,0,10);
sem_init(&full,0,0);
sem_init(&mutex,1,1);
void* status;
pthread_create(&pid1, NULL,(void *)producer , (void *) NULL);
pthread_create(&pid2, NULL,(void *)consumer , (void *) NULL);
pthread_join(pid1,&status);
printf("the exited status of 1st is %s\n",(char*)status);
pthread_join(pid2,&status);
printf("the exited status %s\n",(char*)status);
return 0;
} 
OUTPUT:


TASK 2: READER-WRITER PROBLEM
CODE
#include<pthread.h>
#include<semaphore.h>
#include<stdio.h>
#include<stdlib.h>
pthread_mutex_t x,wsem;
pthread_t tid;
int readcount;
void intialize()
{
pthread_mutex_init(&x,NULL);
pthread_mutex_init(&wsem,NULL);
readcount=0;
}
void* reader(void* param)
{
int waittime;
waittime=rand()%5;
printf("\nReader is trying to enter");
pthread_mutex_lock(&x);
readcount++;
if(readcount==1)pthread_mutex_lock(&wsem);
printf("\n%d Reader is inside",readcount);
pthread_mutex_unlock(&x);
sleep(waittime);
pthread_mutex_lock(&x);
readcount--;
if(readcount==0)
pthread_mutex_unlock(&wsem);
pthread_mutex_unlock(&x);
printf("\nReader is Leaving");
}
void* writer(void* param)
{
int waittime;
waittime=rand()%3;
printf("\nWriter is trying to enter");
pthread_mutex_lock(&wsem);
printf("\nWrite has entered");
sleep(waittime);
pthread_mutex_unlock(&wsem); 
printf("\nWriter is leaving");
sleep(5);
exit(0);
}
int main()
{
int n1,n2,i;
printf("\nEnter the no of readers:");
scanf("%d",&n1);
printf("\nEnter the no of writers:");
scanf("%d",&n2);
for(i=0;i<n1;i++)
pthread_create(&tid,NULL,reader,NULL);  
for(i=0;i<n2;i++)
pthread_create(&tid,NULL,writer,NULL);
sleep(5);
exit(0);
}

OUTPUT:



TASK 3: DINING PHILOSOPHER PROBLEM
CODE
#include<stdio.h>
#include<semaphore.h>
#include<pthread.h>
#define N 5
#define THINKING 0
#define HUNGRY 1
#define EATING 2
#define LEFT (ph_num+4)%N
#define RIGHT (ph_num+1)%N
sem_t mutex;
sem_t S[N];
void* philospher(void*num);
void take_fork(int);
void put_fork(int);
void test(int);
int state[N];
int phil_num[N]={0,1,2,3,4};
int main()
{
int i;pthread_t thread_id[N];
sem_init(&mutex,0,1);
for(i=0;i<N;i++)
sem_init(&S[i],0,0);
for(i=0;i<N;i++)
{
pthread_create(&thread_id[i],NULL,philospher,&phil_num[i]);
printf("\nPhilosopher %d is thinking",i+1);
}
for(i=0;i<N;i++)
pthread_join(thread_id[i],NULL);
}
void* philospher(void* num) 
{
while(1)
{
int* i=num;
sleep(1);
take_fork(*i);
sleep(0);
put_fork(*i);
}
}
void take_fork(int ph_num)
{
sem_wait(&mutex);
state[ph_num]=HUNGRY;
printf("\nPhilosopher %d is Hungry",ph_num+1);
test(ph_num);
sem_post(&mutex);
sem_wait(&S[ph_num]);
sleep(1);
}
void test(int ph_num)
{
if(state[phnum] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING)
{
state[ph_num]=EATING;
sleep(2);
printf("\nPhilosopher %d takes fork %d and %d",ph_num+1,LEFT+1,ph_num+1);
printf("\nPhilosopher %d is Eating",ph_num+1);
sem_post(&S[ph_num]);
}
}
void put_fork(int ph_num)
{
sem_wait(&mutex);
state[ph_num]=THINKING;
printf("\nPhilosopher %d putting fork %d and %d down",ph_num+1,LEFT+1,ph_num+1);
printf("\nPhilosopher %d is thinking",ph_num+1);
test(LEFT);
test(RIGHT);
sem_post(&mutex);
}
Outpu
